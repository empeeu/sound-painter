<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>FDTD Acoustic Simulation app</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <div id="container" style="width:512px; height:512px; margin:auto;">

  </div>
  <script src="js/three.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main()	{
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    varying vec2 vUv;
    uniform float time;
    uniform sampler2D p0I;
    uniform sampler2D p1I;
    uniform vec2 source;
    void main()	{
      float p0 = texture2D(p0I, vUv).x;
      float p1 = texture2D(p1I, vUv).x;
      float d = length(vUv.xy - source);
      gl_FragColor = vec4(d + p0 + p1, 0, 0, 0);
    }
  </script>
  <script>
    // reverences: https://gamedevelopment.tutsplus.com/tutorials/quick-tip-how-to-render-to-a-texture-in-threejs--cms-25686  -- The GOOD one
    // useful : https://github.com/PavelDoGreat/WebGL-Fluid-Simulation/blob/master/script.js
    // https://paveldogreat.github.io/WebGL-Fluid-Simulation/
    // https://stackoverflow.com/questions/21533757/three-js-use-framebuffer-as-texture#comment32726524_21651562
    // https://github.com/mrdoob/three.js/blob/master/examples/webgl_framebuffer_texture.html
    // https://29a.ch/2012/12/16/webgl-fluid-simulation
    // https://mofu-dev.com/en/blog/stable-fluids


  </script>

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script> -->
  <script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>

  <script>
    let container = document.getElementById("container");

    //@author Omar Shehata. 2015.
    //We are loading the Three.js library from the cdn here: https://cdnjs.com/libraries/three.js/
    // Great Resource: https://gamedevelopment.tutsplus.com/tutorials/quick-tip-how-to-render-to-a-texture-in-threejs--cms-25686


    ///////////////////This is the basic scene setup
    var scene = new THREE.Scene();
    var width = container.offsetWidth;
    var height = container.offsetHeight;
    var camera = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, -1000, 1000 );
    camera.position.z = 10;
    // var camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    ///////////////////This is where we create our off-screen render target
    //Create a different scene to hold our buffer objects
    var bufferScene = new THREE.Scene();
    //Create the texture that will store our result

    // TODO; Look into https://threejs.org/docs/api/en/renderers/WebGLArrayRenderTarget.html
    // If the stuff below turns out not to work
    var pressureTexture0 = new THREE.WebGLRenderTarget(
      width, height, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter, 
        type: THREE.FloatType,
        format: THREE.RedFormat
    });
    var pressureTexture1 = new THREE.WebGLRenderTarget(
      width, height, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter, 
        type: THREE.FloatType,
        format: THREE.RedFormat

    });
    var pressureTexture2 = new THREE.WebGLRenderTarget(
      width, height, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter, 
        type: THREE.FloatType,
        format: THREE.RedFormat
    });

    var source = new THREE.Vector2(0.5, 0.5);

    ///And a plane behind it
    uniforms = {
					time: { value: 0.0 },
          p0I: {value: pressureTexture0},
          p1I: {value: pressureTexture1},
          source: {value: source}
				};
    var planeMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent

    });
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF })
    var plane = new THREE.PlaneGeometry(width, height);
    var planeObject = new THREE.Mesh(plane, planeMaterial);
    planeObject.position.z = 0;
    bufferScene.add(planeObject);//We add it to the bufferScene instead of the normal scene!


    ////////////////////////////Now we use our pressureTexture0 as a material to render it onto our main scene
    var planeMaterial = new THREE.MeshBasicMaterial({ map: pressureTexture2.texture });
    var plane2 = new THREE.PlaneGeometry(width, height);
    var mainPlaneObject = new THREE.Mesh(plane2, planeMaterial);
    mainPlaneObject.position.z = 0;
    scene.add(mainPlaneObject);

    //Render everything!
    function render() {
      // setTimeout(function(){
      //   requestAnimationFrame(render);
      // },1000/25);

      
      //Make the plane rotate on plane axes
      // mainPlaneObject.rotation.z += 0.02;
      // mainPlaneObject.rotation.x += 0.01;  

      //Render onto our off screen texture
      renderer.setRenderTarget(pressureTexture2);
      renderer.render(bufferScene, camera);

      //Finally, draw to the screen
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
      
    }
    render();

  </script>
</body>

</html>