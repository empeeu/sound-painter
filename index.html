<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>FDTD Acoustic Simulation app</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <div id="container" style="width:512px; height:512px; margin:auto;">
    
  </div>
  <div><button id="Start" onclick="startStopRender();">Start</button></div> 
  <div>FPS: <label id="FPS"></label></div> 
  <script src="js/three.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main()	{
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    /*
    Main equation on the interior
    d^2(p)/dt^2 = c^2 nabla^2 (p)

    [p(t+1) - 2p(t) + p(t-1)] / dt^2 = c^2 [p(x+1) - 2p(x) + p(x-1)] / dx^2 
                                     + c^2 [p(y+1) - 2p(y) + p(y-1)] / dy^2 

    p(t+1) = 2p(t) - p(t-1) + dt^2c^2 [p(x+1) - 2p(x) + p(x-1)] / dx^2 
                            + dt^2c^2 [p(y+1) - 2p(y) + p(y-1)] / dy^2 

    Open Boundary Conditions:
    dp/dt = +- c dp/dn
    p(t + 1) = p(t) +-c dt /dn (p(n) - p(n-1))
    * or rearranging using a "ghost" node (outside the texture)
    p(n-1) = p(n) +-dn / (cdt) (p(t+1) - p(t)) 

    Damping / Absorption: (always make the change in pressure smaller)
    p = \alpha / t
    dp / dt = -\alpha / t^2
    d2p / dt2 = alpha / t^3 == alpha p^3

    or 

    dp/dt = \alpha dt/dt  // Really? no negative sign?
    dp2/dt2 = \alpha dp/dt
    */
    varying vec2 vUv;
    uniform float time;
    uniform sampler2D p0I;
    uniform sampler2D p1I;
    uniform vec4 source;
    uniform vec2 dxdy;
    uniform vec2 pxpy;
    uniform vec2 domain;
    uniform float c;
    uniform float dt;
    void main()	{
      // A few constants
      float dt2 = dt * dt;
      float dt2c2 = dt2 * c * c;

      // Get the texture values
      float p0 = texture2D(p0I, vUv).x;
      float p1 = texture2D(p1I, vUv).x;
      float offset = 1.0;
      float p1e = texture2D(p1I, vUv + offset * vec2(pxpy.x, 0)).x;
      float p1w = texture2D(p1I, vUv - offset * vec2(pxpy.x, 0)).x;
      float p1n = texture2D(p1I, vUv + offset * vec2(0, pxpy.y)).x;
      float p1s = texture2D(p1I, vUv - offset * vec2(0, pxpy.y)).x;
      float d = length(vUv.xy - source.xy);

      float edgeAlpha = 0.0;
      float edgeAlphaVal = 0.04/dt;

      // Handle Boundary conditions
      float onCorner;
      vec2 cornerOffset;
      float onEdge;
      offset = 1.0;
      // East-West edges
      onEdge = float(vUv.x <= pxpy.x * offset);
      cornerOffset.x = -offset * pxpy.x * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1w = p1w * (1.0 - onEdge) + onEdge * (p1 - dxdy.x / c / dt * (p1 - p0));
      onEdge = float(vUv.x >= (1.0 - pxpy.x * offset));
      cornerOffset.x = offset * pxpy.x * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1e = p1e * (1.0 - onEdge) + onEdge * (p1 - dxdy.x / c / dt * (p1 - p0));

      // North-South edges
      onEdge = float(vUv.y <= pxpy.y * offset);
      cornerOffset.y = -offset * pxpy.y * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1s = p1s * (1.0 - onEdge) + onEdge * (p1 - dxdy.y / c / dt * (p1 - p0));
      onEdge = float(vUv.y >= (1.0 - pxpy.y * offset));
      cornerOffset.y = offset * pxpy.y * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1n = p1n * (1.0 - onEdge) + onEdge * (p1 - dxdy.y / c / dt * (p1 - p0));

      float xParts, yParts;
      float dn;
      if (onCorner >= 2.0){
        dn = length(dxdy);
        p1n = texture2D(p1I, vUv - cornerOffset).x;
        p1s = p1 - dn / c / dt * (p1 - p0);
        xParts = 0.0;
        yParts = (p1n - 2.0 * p1 + p1s) / (dn * dn);
      } else {
        xParts = (p1e - 2.0 * p1 + p1w) / (dxdy.x * dxdy.x);
        yParts = (p1n - 2.0 * p1 + p1s) / (dxdy.y * dxdy.y);
      }

      float timeParts = 2.0 * p1 - p0;
      float sourceParts = dt2 * float(d < (length(dxdy) * 1.0)) * source.z * source.w * source.w * 39.47841 * cos(6.283185 * time * source.w);
      float absorp = dt * edgeAlpha * (p1 - p0);
      float p = timeParts + dt2c2 * (xParts + yParts) + sourceParts + absorp;

      //gl_FragColor = vec4(timeParts + (xParts + yParts) + sourceParts, 0, 0, 0);
      gl_FragColor = vec4(p, 0, 0, 0);
    }
  </script>
  <script id="fragmentShader2" type="x-shader/x-fragment">
    varying vec2 vUv;
    uniform sampler2D pI;
    void main()	{
      float p = texture2D(pI, vUv).x;
      //gl_FragColor = vec4(p, p*p, sin(p * 50.0), 1.0);
      gl_FragColor = vec4(p / 2.0 + 0.5, p / 2.0 + 0.5, p / 2.0 + 0.5, 1.0);
    }
  </script>
  <script>
    // reverences: https://gamedevelopment.tutsplus.com/tutorials/quick-tip-how-to-render-to-a-texture-in-threejs--cms-25686  -- The GOOD one
    // useful : https://github.com/PavelDoGreat/WebGL-Fluid-Simulation/blob/master/script.js
    // https://paveldogreat.github.io/WebGL-Fluid-Simulation/
    // https://stackoverflow.com/questions/21533757/three-js-use-framebuffer-as-texture#comment32726524_21651562
    // https://github.com/mrdoob/three.js/blob/master/examples/webgl_framebuffer_texture.html
    // https://29a.ch/2012/12/16/webgl-fluid-simulation
    // https://mofu-dev.com/en/blog/stable-fluids


  </script>

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script> -->
  <script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>

  <script>
    // This is the HTML element that houses the threejs canvas
    let container = document.getElementById("container");

    ///////////////////This is the basic scene setup
    var scene = new THREE.Scene();
    var widthContainer = container.offsetWidth;
    var heightContainer = container.offsetHeight;
    var camera = new THREE.OrthographicCamera(- widthContainer / 2, widthContainer / 2, heightContainer / 2, - heightContainer / 2, -1000, 1000);
    camera.position.z = 10;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(widthContainer, heightContainer);
    container.appendChild(renderer.domElement);

    ///////////////////This is where we create our off-screen render target
    //Create a different scene to hold our buffer objects
    var bufferScene = new THREE.Scene();
    //Create the textures that will store our results and intermediate
    var widthDomain = 256*4;
    var heightDomain = 256*4;

    var pressureTexture0 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      format: THREE.RedFormat
    });
    var pressureTexture1 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      format: THREE.RedFormat

    });
    var pressureTexture2 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      format: THREE.RedFormat
    });

    var textureRing = [pressureTexture0, pressureTexture1, pressureTexture2];
    
    // Now create the supporing data
    // initial pressure source
    var source = new THREE.Vector4(0.5, 0.5, 64, 16);

    // discretization. We assume the domain has a maximum dimension of 1
    // and then the other dimension depends on the aspect ratio
    if (widthContainer < heightContainer){
      var domainSizeWorld = new THREE.Vector2(1 * widthContainer / heightContainer, 1);
    } else {
      var domainSizeWorld = new THREE.Vector2(1, 1 * heightContainer / widthContainer);
    }
    var dxdy = new THREE.Vector2(domainSizeWorld.x / widthDomain, domainSizeWorld.y / heightDomain);

    // The u-v coordinates can be finer / coarser than the dxdy of the computational domain. 
    // so, we need a conversion between the two
    var pxpy = new THREE.Vector2(1 / widthDomain, 1 / heightDomain); 

    var c = 1.0;  // speed of sound
    var dt = 0.95 / Math.sqrt(2) * Math.min(dxdy.x, dxdy.y) / c;

    ///Create the uniforms for the computations
    uniforms = {
      time: { value: 0.0 },
      p0I: { value: pressureTexture0 },
      p1I: { value: pressureTexture1 },
      source: { value: source },
      dxdy: { value : dxdy },
      pxpy: { value : pxpy },
      domain: { value : domainSizeWorld },
      c: { value : c },
      dt: { value : dt }
    };
    /// This is the material that houses the custom shader that does the computation
    var planeMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent

    });
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF });
    /// We attach this shader to a plane and add it to our buffer scne
    var plane = new THREE.PlaneGeometry(widthContainer, heightContainer);
    var planeObject = new THREE.Mesh(plane, planeMaterial);
    planeObject.position.z = 0;
    bufferScene.add(planeObject);//We add it to the bufferScene instead of the normal scene!


    ////////////////////////////Now we use our pressureTexture as a material to render it onto our main scene
    uniforms2 = {
      pI: { value: pressureTexture2.texture },
    };
    var planeMaterial2 = new THREE.ShaderMaterial({
      uniforms: uniforms2,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader2').textContent
    });
    var plane2 = new THREE.PlaneGeometry(widthContainer, heightContainer);
    var mainPlaneObject = new THREE.Mesh(plane2, planeMaterial2);
    mainPlaneObject.position.z = 0;
    scene.add(mainPlaneObject);
    
    //Render everything!
    var simTime = 0;
    var startTime = 0;
    var fpsOutput = document.getElementById("FPS");
    var fps = 0;
    var i = 0;
    function render() {
      if (!doRunSim){
        return;
      }
      setTimeout(function(){
        requestAnimationFrame(render);
      },Math.max(0, 1000 / 30 - (Date.now() - startTime)));
      //Make the plane rotate on plane axes
      //mainPlaneObject.rotation.z += 0.02;
      //mainPlaneObject.rotation.x += 0.01;
      fps = 0.9 * fps + 0.05 * (1000 / (Date.now() - startTime));
      fpsOutput.innerText = Math.round(fps) + ' TIME: ' + Math.round(simTime * 100) / 100;
      startTime = Date.now();
      //Render onto our off screen texture
      for (var j=0; j< 4; j++){
        simTime += dt;
        renderer.setRenderTarget(textureRing[2]);
        renderer.render(bufferScene, camera);
        uniforms.time.value = uniforms.time.value + dt;
        textureRing = [textureRing[1], textureRing[2], textureRing[0]];
        uniforms.p0I.value = textureRing[0].texture;
        uniforms.p1I.value = textureRing[1].texture;
        uniforms.source.value.x = 0.5 * (Math.cos(2 * 3.14159 * simTime / 2) + 1);
      }

      //Finally, draw to the screen
      uniforms2.pI.value = textureRing[2].texture;
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
      i += 1;

    }
    // render();
    var doRunSim = false;
    function startStopRender(){
      var button = document.getElementById("Start");
      if (doRunSim){
        // Already running, stop it
        button.innerText = "Start"
        doRunSim = false;
      } else {
        doRunSim = true;
        button.innerText = "Stop"
        render();
      }
    }

  </script>
</body>

</html>