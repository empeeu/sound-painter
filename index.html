<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>FDTD Acoustic Simulation app</title>
  <style>
    body {
      margin: 0;
    }

    :root {
      --amp-track-color: 'white';
      --phase-track-color: 'white';
    }

    #canvas-container {
      /* position: fixed;
      top: 0px;
      width: 100%; */
    }

    #drawing-canvas {
      position: absolute;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: -512px;
      left: 0px;
      right: 0px;
    }

    #frequency-select {
      width: 256px;
      height: 20px;
    }

    #frequency-select::-webkit-slider-runnable-track {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select:focus::-webkit-slider-runnable-track {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select::-moz-range-track {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select::-ms-fill-lower {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select::-ms-fill-upper {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select:focus::-ms-fill-lower {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #frequency-select:focus::-ms-fill-upper {
      background-image: url("frequencyRamp.png");
      background-size: contain;
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #amplitude-select {
      width: 256px;
      height: 20px;
    }
    
    #amplitude-select::-moz-range-track {
      background: var(--amp-track-color);
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #phase-select {
      width: 256px;
      height: 20px;
    }
    
    #phase-select::-moz-range-track {
      background: var(--phase-track-color);
      height: 5px;
      border-style: solid;
      border-width: 1px;
    }

    #draw-line-width {
      width: 3em;
    }
  </style>
</head>

<body>
  <div id="canvas-container">
    <canvas id="drawing-canvas" height="512px" width="512px"></canvas>
  </div>
  <div id="container" style="width:512px; height:512px; margin:auto;">
  </div>
  <div>
    <input onchange="updateDrawColor();" id="frequency-select" type="range" min=0.05 max=1 step=0.01 value=0.5 />
    <input onchange="updateDrawColor();" id="amplitude-select" type="range" min=0.05 max=1 step=0.01 value=0.5 />
    <input onchange="updateDrawColor();" id="phase-select" type="range" min=0.05 max=1 step=0.01 value=0.5 />
  </div>
  <div>
    <label>Absorption Coefficient: </label><input onchange="uniforms.absorpCoeff.value=this.value;" type="range" min=0 max=0.1 step=0.001 value=0 />
  </div>

  <div>
    <button id="Start" onclick="startStopRender();">Start</button>
    <label> Draw Line-Width<input id="draw-line-width" type=number min=1 max=50 value=2 onchange="drawWidth=parseInt(this.value);">
    <label> Draw Free-Hand</label><input type="checkbox" id="free-hand-draw" checked /></div>
  <div>
    <button id="draw-wall" onclick="setDrawColor('#000000ff');">Wall</button>
    <button id="draw-free-surface" onclick="setDrawColor('#ffffffff');">Free-Surface</button>
    <button id="draw-erase" onclick="eraseColor();">Erase</button>
    <button id="pressure-erase" onclick="pressureErase();">Erase Pressure Field</button>
    <button id="test-sound" onclick="mouseTestSound();">Turn Mouse Test Source ON</button>
    </div>
    <div>
      x: <label id="mouse-x"></label>, y: <label id="mouse-y"></label>, p: <label id="mouse-p"></label> 
    </div>
    <div>
     FPS: <label id="FPS"></label>
    </div>
  <script src="js/three.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main()	{
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    /*
    Main equation on the interior
    d^2(p)/dt^2 = c^2 nabla^2 (p)

    [p(t+1) - 2p(t) + p(t-1)] / dt^2 = c^2 [p(x+1) - 2p(x) + p(x-1)] / dx^2 
                                     + c^2 [p(y+1) - 2p(y) + p(y-1)] / dy^2 

    p(t+1) = 2p(t) - p(t-1) + dt^2c^2 [p(x+1) - 2p(x) + p(x-1)] / dx^2 
                            + dt^2c^2 [p(y+1) - 2p(y) + p(y-1)] / dy^2 

    Open Boundary Conditions:
    dp/dt = +- c dp/dn
    p(t + 1) = p(t) +-c dt /dn (p(n) - p(n-1))
    * or rearranging using a "ghost" node (outside the texture)
    p(n-1) = p(n) +-dn / (cdt) (p(t+1) - p(t)) 

    Damping / Absorption: (always make the change in pressure smaller)
    p = \alpha / t
    dp / dt = -\alpha / t^2
    d2p / dt2 = alpha / t^3 == alpha p^3

    or 

    dp/dt = \alpha dt/dt  // Really? no negative sign?
    dp2/dt2 = \alpha dp/dt
    */
    varying vec2 vUv;
    uniform float time;
    uniform sampler2D p0I;
    uniform sampler2D p1I;
    uniform vec4 source;
    uniform vec2 dxdy;
    uniform vec2 pxpy;
    uniform vec2 domain;
    uniform float c;
    uniform float dt;
    uniform sampler2D walls;
    uniform float textSourceAmp;
    uniform float textSourceFreq;
    uniform float absorpCoeff;

    vec3 HSVtoRGB(in vec3 HSV)
    {
        float H   = HSV.x;
        float R   = abs(H * 6.0 - 3.0) - 1.0;
        float G   = 2.0 - abs(H * 6.0 - 2.0);
        float B   = 2.0 - abs(H * 6.0 - 4.0);
        vec3  RGB = clamp( vec3(R,G,B), 0.0, 1.0 );
        return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;
    }

    vec3 RGBtoHSV(in vec3 RGB)
    {
        float Epsilon = 1e-7;
        vec4  P   = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);
        vec4  Q   = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);
        float C   = Q.x - min(Q.w, Q.y);
        float H   = abs((Q.w - Q.y) / (6.0 * C + Epsilon) + Q.z);
        vec3  HCV = vec3(H, C, Q.x);
        float S   = HCV.y / (HCV.z + Epsilon);
        return vec3(HCV.x, S, HCV.z);
    }

    void main()	{
      // A few constants
      float dt2 = dt * dt;
      float dt2c2 = dt2 * c * c;
      float dz = length(dxdy);

      // Get the texture values
      vec4 p0 = texture2D(p0I, vUv);
      vec4 p1 = texture2D(p1I, vUv);
      float offset = 1.0;
      vec4 p1e = texture2D(p1I, vUv + offset * vec2(pxpy.x, 0));
      vec4 p1w = texture2D(p1I, vUv - offset * vec2(pxpy.x, 0));
      vec4 p1n = texture2D(p1I, vUv + offset * vec2(0, pxpy.y));
      vec4 p1s = texture2D(p1I, vUv - offset * vec2(0, pxpy.y));
     
      vec4 wall1e = texture2D(walls, vUv + offset * vec2(pxpy.x, 0));
      vec4 wall1w = texture2D(walls, vUv - offset * vec2(pxpy.x, 0));
      vec4 wall1n = texture2D(walls, vUv + offset * vec2(0, pxpy.y));
      vec4 wall1s = texture2D(walls, vUv - offset * vec2(0, pxpy.y));
      vec3 wallRGB = texture2D(walls, vUv).xyz;
      vec3 wall = RGBtoHSV(wallRGB);

      float d = length(vUv.xy - source.xy);

      float edgeAlpha = 0.0;
      float edgeAlphaVal = 0.04/dt;

      // Handle Boundary conditions
      float onCorner;
      vec2 cornerOffset;
      float onEdge;
      offset = 1.0;
      // East-West edges
      onEdge = float(vUv.x <= pxpy.x * offset);
      cornerOffset.x = -offset * pxpy.x * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1w = p1w * (1.0 - onEdge) + onEdge * (p1 - dxdy.x / c / dt * (p1 - p0));
      onEdge = float(vUv.x >= (1.0 - pxpy.x * offset));
      cornerOffset.x = offset * pxpy.x * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1e = p1e * (1.0 - onEdge) + onEdge * (p1 - dxdy.x / c / dt * (p1 - p0));

      // North-South edges
      onEdge = float(vUv.y <= pxpy.y * offset);
      cornerOffset.y = -offset * pxpy.y * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1s = p1s * (1.0 - onEdge) + onEdge * (p1 - dxdy.y / c / dt * (p1 - p0));
      onEdge = float(vUv.y >= (1.0 - pxpy.y * offset));
      cornerOffset.y = offset * pxpy.y * onEdge;
      onCorner += onEdge;
      edgeAlpha += onEdge * edgeAlphaVal;
      p1n = p1n * (1.0 - onEdge) + onEdge * (p1 - dxdy.y / c / dt * (p1 - p0));

      // Up down "edges"
      vec4 p1up = (p1 - dz / c / dt * (p1 - p0));
      
      ///////// Apply wall boundary conditions
      // Rigid wall
      p1n = p1n * (1.0 - float(wall1n.w > 0.99) * float(wall1n.x < 0.01) * float(wall1n.y < 0.01) * float(wall1n.z < 0.01));
      p1s = p1s * (1.0 - float(wall1s.w > 0.99) * float(wall1s.x < 0.01) * float(wall1s.y < 0.01) * float(wall1s.z < 0.01));
      p1w = p1w * (1.0 - float(wall1w.w > 0.99) * float(wall1w.x < 0.01) * float(wall1w.y < 0.01) * float(wall1w.z < 0.01));
      p1e = p1e * (1.0 - float(wall1e.w > 0.99) * float(wall1e.x < 0.01) * float(wall1e.y < 0.01) * float(wall1e.z < 0.01));

      // Pressure-release wall
      float isPRWall;
      isPRWall = float(wall1n.w > 0.99) * float(wall1n.x > 0.99)* float(wall1n.y > 0.99)* float(wall1n.z > 0.99);
      p1n = p1n * (1.0 - isPRWall) + p1 * isPRWall;
      isPRWall = float(wall1s.w > 0.99) * float(wall1s.x > 0.99)* float(wall1s.y > 0.99)* float(wall1s.z > 0.99);
      p1s = p1s * (1.0 - isPRWall) + p1 * isPRWall;
      isPRWall = float(wall1w.w > 0.99) * float(wall1w.x > 0.99)* float(wall1w.y > 0.99)* float(wall1w.z > 0.99);
      p1w = p1w * (1.0 - isPRWall) + p1 * isPRWall;
      isPRWall = float(wall1e.w > 0.99) * float(wall1e.x > 0.99)* float(wall1e.y > 0.99)* float(wall1e.z > 0.99);
      p1e = p1e * (1.0 - isPRWall) + p1 * isPRWall;


      // Compute the integration of pressures
      vec4 xParts, yParts, zParts;
      float dn;
      if (onCorner >= 2.0){
        dn = length(dxdy);
        p1n = texture2D(p1I, vUv - cornerOffset);
        p1s = p1 - dn / c / dt * (p1 - p0);
        xParts = vec4(0.0,0.0,0.0,0.0);
        yParts = (p1n - 2.0 * p1 + p1s) / (dn * dn);
      } else {
        xParts = (p1e - 2.0 * p1 + p1w) / (dxdy.x * dxdy.x);
        yParts = (p1n - 2.0 * p1 + p1s) / (dxdy.y * dxdy.y);
      }

      vec4 timeParts = 2.0 * p1 - p0;
      float f = textSourceFreq * (pow(2.0, source.w) - 1.0);
      float mouseSourceParts = dt2 * float(d < (length(dxdy) * 1.0)) * float(source.z > 0.0) * f * f * 39.47841 * cos(6.283185 * time * f);
      float mouseSourceParts2 =  textSourceAmp * source.z * dt2 * float(d < (length(dxdy) * 1.0)) * f * f * 39.47841 * sin(6.283185 * time * f);
      // use the transparency to keep track of the amplitude
      vec4 sourceParts = vec4(source.w * mouseSourceParts, mouseSourceParts, source.z * textSourceAmp * mouseSourceParts, mouseSourceParts2);
      
      f = textSourceFreq * (pow(2.0, wall.x) - 1.0);
      sourceParts.y += dt2 * float(wall.y > 0.05) * 39.47841 * f * f * cos(6.283185 * (time * f + wall.z));
      sourceParts.x += wall.x * sourceParts.y;
      sourceParts.z += wall.y * textSourceAmp * sourceParts.y;
      sourceParts.w += wall.y * textSourceAmp * dt2 * float(wall.y > 0.05) * 39.47841 * f * f * sin(6.283185 * (time * f + wall.z));
      vec4 absorp = dt * edgeAlpha * (p1 - p0) + absorpCoeff * dt2c2 * (p1up - p1) / (dz * dz);
      vec4 p = timeParts + dt2c2 * (xParts + yParts + zParts) + sourceParts + absorp;

      gl_FragColor = p;
    }
  </script>
  <script id="fragmentShader2" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D pI;
      vec3 HSVtoRGB(in vec3 HSV)
      {
          float H   = HSV.x;
          float R   = abs(H * 6.0 - 3.0) - 1.0;
          float G   = 2.0 - abs(H * 6.0 - 2.0);
          float B   = 2.0 - abs(H * 6.0 - 4.0);
          vec3  RGB = clamp( vec3(R,G,B), 0.0, 1.0 );
          return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;
      }
      void main()	{
        vec4 p = texture2D(pI, vUv);
        float hue = p.x / p.y;
        float sat = sqrt(p.z * p.z + p.w * p.w);
        float val = 0.5 + (p.y) / 2.0;
        vec3 hsv = vec3(hue, sat, val);
        vec3 prgb = HSVtoRGB(hsv);

        //gl_FragColor = vec4(p, p*p, sin(p * 50.0), 1.0);
        //gl_FragColor = vec4(p.x / 2.0 + 0.5, p.y / 2.0 + 0.5, p.z / 2.0 + 0.5, 1.0);
        gl_FragColor = vec4(prgb, 1.0);
        //gl_FragColor = vec4(p.z / 2.0 + 0.5, p.w / 2.0 + 0.5, 0.5, 1.0);
      }
  </script>
  <script id="fragmentShader3" type="x-shader/x-fragment">
    void main()	{
      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
  </script>
  <script>
      // reverences: https://gamedevelopment.tutsplus.com/tutorials/quick-tip-how-to-render-to-a-texture-in-threejs--cms-25686  -- The GOOD one
      // useful : https://github.com/PavelDoGreat/WebGL-Fluid-Simulation/blob/master/script.js
      // https://paveldogreat.github.io/WebGL-Fluid-Simulation/
      // https://stackoverflow.com/questions/21533757/three-js-use-framebuffer-as-texture#comment32726524_21651562
      // https://github.com/mrdoob/three.js/blob/master/examples/webgl_framebuffer_texture.html
      // https://29a.ch/2012/12/16/webgl-fluid-simulation
      // https://mofu-dev.com/en/blog/stable-fluids


  </script>

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script> -->
  <script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>

  <script>
    function setupCanvasDrawing() {
      const drawingCanvas = document.getElementById('drawing-canvas');
      drawingContext = drawingCanvas.getContext('2d');

      // draw gray transparent background

      // drawingContext.fillStyle = '#FFFFFFFF';
      // drawingContext.fillRect( 504, 504, 8, 8 );

      var drawingTexture = new THREE.CanvasTexture(drawingCanvas);

      var paint = false;
      var mouseSourceIsOn = false;
      var drawFreehand = false;

      drawingCanvas.addEventListener('pointerdown', function (e) {

        paint = true & !mouseSource;
        drawFreehand = document.getElementById('free-hand-draw').checked;
        mouseSourceIsOn = mouseSource;
        if (paint){
          drawingContext.beginPath();
          drawStartPos.set(e.offsetX, e.offsetY);
        }
        if (mouseSource) {
          source.z = parseFloat(document.getElementById('amplitude-select').value);
          source.w = parseFloat(document.getElementById('frequency-select').value);
        }
      });

      drawingCanvas.addEventListener('pointermove', function (e) {
        if (paint & drawFreehand) draw(drawingContext, e.offsetX, e.offsetY);
        if (mouseSource) {
          source.x = e.offsetX / widthContainer;
          source.y = (heightContainer - e.offsetY) / heightContainer;
          uniforms.source.value = source;
        }
        var mx = document.getElementById('mouse-x');
        var my = document.getElementById('mouse-y');
        var mp = document.getElementById('mouse-p');
        mx.innerText = e.offsetX;
        my.innerText = e.offsetY;
        renderer.readRenderTargetPixels(textureRing[2], e.offsetX, heightContainer - e.offsetY, 1, 1, pressureBuf);
        mp.innerText = pressureBuf[2];


      });

      drawingCanvas.addEventListener('pointerup', function (e) {
        if (paint) draw(drawingContext, e.offsetX, e.offsetY);
        if (mouseSource) source.z = 0
        paint = false;

      });

      drawingCanvas.addEventListener('pointerleave', function () {

        paint = false;

      });

      return drawingTexture;

    }
    function draw(drawContext, x, y) {
      drawContext.moveTo(drawStartPos.x, drawStartPos.y);
      let rgba = hexColtoIntArr(drawColor);
      drawContext.strokeStyle = "rgba("+rgba + ")";
      drawContext.lineWidth = drawWidth;
      if ((x === drawStartPos.x) & (y === drawStartPos.y)){
        y+=1;
        x+=1;
      }
      drawContext.lineTo(x, y);
      drawContext.stroke();
      // reset drawing start position to current position.
      drawStartPos.set(x, y);
      // need to flag the map as needing updating.
      // material.map.needsUpdate = true;
      drawingTexture.needsUpdate = true;

    }

    function setDrawColor(color) {
      drawColor = color;
      drawingContext.globalCompositeOperation = "source-over"; 
    }

    function eraseColor(){
      setDrawColor('#888888ff');
      drawingContext.globalCompositeOperation = "destination-out"; 
    }

    function pressureErase(){
      renderer.setRenderTarget(pressureTexture0);
      renderer.render(initScene, camera);
      renderer.setRenderTarget(pressureTexture1);
      renderer.render(initScene, camera);
      renderer.setRenderTarget(pressureTexture2);
      renderer.render(initScene, camera);
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    }

    function str_pad_left(string, pad, length) {
    // Pads the number with zeros to look nice for the timer display
    // string: string
    //    string to pad
    // pad: string
    //     What to pad with
    // length: int
    //     Length of section
    return (new Array(length + 1).join(pad) + string).slice(-length);
    }

    function hexColtoIntArr(c){
      let r = (parseInt(c.substring(1, 3), 16));
      let g = (parseInt(c.substring(3, 5), 16));
      let b = (parseInt(c.substring(5, 7), 16));
      let a = (parseInt(c.substring(7, 9), 16));
      return [r, g, b, a];
    }

    function float2Hex(n){
      return str_pad_left(Math.round(n * 255).toString(16), "0", 2);
    }

    // From: https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
    // input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]
    function hsv2rgb(h,s,v) 
    {                              
      let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
      rgb = [f(5),f(3),f(1)];       
      return "#" + float2Hex(rgb[0]) + float2Hex(rgb[1]) + float2Hex(rgb[2]);
    }   

    function updateDrawColor() {
      var hue = document.getElementById("frequency-select").value;
      hue = hue * 212 / 255 * 360;
      var sat = document.getElementById("amplitude-select").value;
      var val = document.getElementById("phase-select").value;

      var rgb = hsv2rgb(hue, sat, val) + "88";
      
      let ampRamp = document.getElementById('amplitude-select');
      let lowramp = hsv2rgb(hue, 0, 1);
      let highramp = hsv2rgb(hue, 1, 1);
      
      ampRamp.style.setProperty("--amp-track-color", 'linear-gradient(to right,' + lowramp + ',' + highramp + ')');

      let phaseRamp = document.getElementById('phase-select');
      lowramp = hsv2rgb(hue, 1, 0);
      highramp = hsv2rgb(hue, 1, 1);
      
      phaseRamp.style.setProperty("--phase-track-color", 'linear-gradient(to right,' + lowramp + ',' + highramp + ')');


      setDrawColor(rgb);
    }

    function mouseTestSound(){
      if (mouseSource){
        mouseSource = false;
        document.getElementById("test-sound").innerText = "Turn Mouse Test Source ON"
      } else {
        mouseSource = true;
        document.getElementById("test-sound").innerText = "Turn Mouse Test Source OFF"
      }
    }
  </script>

  <script>
    // This is the HTML element that houses the threejs canvas
    var container = document.getElementById("container");

    /////////////////// This is for our Drawing CANVAS
    const drawStartPos = new THREE.Vector2();
    var drawColor = "#00000000";
    var drawWidth = 2;
    var drawingContext;
    var drawingTexture = setupCanvasDrawing();
    var mouseSource = false;
    updateDrawColor();

    ////////////////// This is for probing the pressure values
    var pressureBuf = new Float32Array(4);



    ///////////////////This is the basic scene setup
    var scene = new THREE.Scene();
    var widthContainer = container.offsetWidth;
    var heightContainer = container.offsetHeight;
    var camera = new THREE.OrthographicCamera(- widthContainer / 2, widthContainer / 2, heightContainer / 2, - heightContainer / 2, -1000, 1000);
    camera.position.z = 10;

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(widthContainer, heightContainer);
    container.appendChild(renderer.domElement);

    ///////////////////This is where we create our off-screen render target
    //Create a different scene to hold our buffer objects
    var initScene = new THREE.Scene();
    var bufferScene = new THREE.Scene();
    //Create the textures that will store our results and intermediate
    var widthDomain = widthContainer;
    var heightDomain = heightContainer;

    var pressureTexture0 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      // format: THREE.RedFormat
    });
    var pressureTexture1 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      // format: THREE.RedFormat

    });
    var pressureTexture2 = new THREE.WebGLRenderTarget(
      widthDomain, heightDomain, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      type: THREE.FloatType,
      // format: THREE.RedFormat
    });

    var textureRing = [pressureTexture0, pressureTexture1, pressureTexture2];

    // Create an initialization shader 
    var initMaterial = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader3').textContent
    });
        // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF });
    /// We attach this shader to a plane and add it to our buffer scne
    var initPlane = new THREE.PlaneGeometry(widthContainer, heightContainer);
    var initPlaneObject = new THREE.Mesh(initPlane, initMaterial);
    initPlaneObject.position.z = 0;
    initScene.add(initPlaneObject);//We add it to the bufferScene instead of the normal scene!

    // Now create the supporing data
    // initial pressure source
    var source = new THREE.Vector4(0.5, 0.5, 0, 64);

    // discretization. We assume the domain has a maximum dimension of 1
    // and then the other dimension depends on the aspect ratio
    if (widthContainer < heightContainer) {
      var domainSizeWorld = new THREE.Vector2(1 * widthContainer / heightContainer, 1);
    } else {
      var domainSizeWorld = new THREE.Vector2(1, 1 * heightContainer / widthContainer);
    }
    var dxdy = new THREE.Vector2(domainSizeWorld.x / widthDomain, domainSizeWorld.y / heightDomain);

    // The u-v coordinates can be finer / coarser than the dxdy of the computational domain. 
    // so, we need a conversion between the two
    var pxpy = new THREE.Vector2(1 / widthDomain, 1 / heightDomain);

    var c = 1.0;  // speed of sound
    var dt = 0.95 / Math.sqrt(2) * Math.min(dxdy.x, dxdy.y) / c;

    ///Create the uniforms for the computations
    uniforms = {
      time: { value: 0.0 },
      p0I: { type: "t", value: pressureTexture0.texture },
      p1I: { type: "t", value: pressureTexture1.texture },
      source: { value: source },
      dxdy: { value: dxdy },
      pxpy: { value: pxpy },
      domain: { value: domainSizeWorld },
      c: { value: c },
      dt: { value: dt },
      walls: {
        type: "t",
        value: drawingTexture
      },
      textSourceAmp: {value: 25.0},
      textSourceFreq: { value: widthDomain / 8},
      absorpCoeff: { value : 0.0}
    };
    /// This is the material that houses the custom shader that does the computation
    var planeMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent

    });
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF });
    /// We attach this shader to a plane and add it to our buffer scne
    var plane = new THREE.PlaneGeometry(widthContainer, heightContainer);
    var planeObject = new THREE.Mesh(plane, planeMaterial);
    planeObject.position.z = 0;
    bufferScene.add(planeObject);//We add it to the bufferScene instead of the normal scene!


    ////////////////////////////Now we use our pressureTexture as a material to render it onto our main scene
    uniforms2 = {
      pI: { value: pressureTexture2.texture },
    };
    var planeMaterial2 = new THREE.ShaderMaterial({
      uniforms: uniforms2,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader2').textContent
    });
    var plane2 = new THREE.PlaneGeometry(widthContainer, heightContainer);
    var mainPlaneObject = new THREE.Mesh(plane2, planeMaterial2);
    mainPlaneObject.position.z = 0;
    scene.add(mainPlaneObject);

    //Render everything!
    var simTime = 0;
    var startTime = 0;
    var fpsOutput = document.getElementById("FPS");
    var fps = 0;
    var i = 0;
    function render() {
      if (!doRunSim) {
        return;
      }
      setTimeout(function () {
        requestAnimationFrame(render);
      }, Math.max(0, 1000 / 30 - (Date.now() - startTime)));
      //Make the plane rotate on plane axes
      //mainPlaneObject.rotation.z += 0.02;
      //mainPlaneObject.rotation.x += 0.01;
      fps = 0.9 * fps + 0.05 * (1000 / (Date.now() - startTime));
      fpsOutput.innerText = Math.round(fps) + ' TIME: ' + Math.round(simTime * 100) / 100;
      startTime = Date.now();
      //Render onto our off screen texture
      for (var j = 0; j < 1; j++) {
        simTime += dt;
        renderer.setRenderTarget(textureRing[2]);
        renderer.render(bufferScene, camera);
        uniforms.time.value = uniforms.time.value + dt;
        textureRing = [textureRing[1], textureRing[2], textureRing[0]];
        uniforms.p0I.value = textureRing[0].texture;
        uniforms.p1I.value = textureRing[1].texture;
        uniforms.walls.value = drawingTexture;
      }

      //Finally, draw to the screen
      uniforms2.pI.value = textureRing[2].texture;
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
      i += 1;

      // TO READ pixels off a float texture, the texture needs to be in RGBA format
      // buff = new Float32Array(4);
      // renderer.readRenderTargetPixels(pressureTexture0, 64, 64, 1, 1, buff);
      // https://r105.threejsfundamentals.org/threejs/lessons/threejs-indexed-textures.html

    }
    // render();
    var doRunSim = false;
    function startStopRender() {
      var button = document.getElementById("Start");
      if (doRunSim) {
        // Already running, stop it
        button.innerText = "Start"
        doRunSim = false;
      } else {
        doRunSim = true;
        button.innerText = "Stop"
        render();
      }
    }
    startStopRender();

  </script>
</body>

</html>